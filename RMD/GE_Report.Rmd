---
header-includes:
  - \usepackage{lscape}
  - \newcommand{\blandscape}{\begin{landscape}}
  - \newcommand{\elandscape}{\end{landscape}}
  - \pagenumbering{gobble}

geometry: margin=0.75in
output: pdf_document
params:
  projectname: "Project"
  thedate: !r Sys.Date()
  pathd: "/"
  infof: ".info"
  mappingf: "none"
title: "Gene Expression Report for `r params$projectname`"
author: "Institute for Genome Sciences (IGS) Trancriptomics Analysis Team"
date: "`r params$thedate`"
---

\ 
\ 
\ 

This report is useful for viewing gene expression for samples and groups. This can show how the
samples cluster, whether there are outliers, and how well the groups separate. The Gene
Expression report visualises the aligned reads from each sample. The read counts for each
transcript are generated by HTseq, the reads are either normalized as CPM (count per million
reads), or RPKM (Reads Per Kilobase Million). For PCA plot, the input reads are DESeq normalized
read counts. Euclidean distance and Pearson correlations are used to display the similarity of
transcriptome profiles for all the samples. Figures 1 and 2 show read depth and density across
the read counts for each sample. Figures 3-6 indicate clustering of samples based on Euclidean
distances or Pearson correlations, the Euclidean distances or Pearson co-efficient is calculated
based on CPM. The PCA plots (Figure 7) uses the first two principle component to display the
similarity/dissimilarity of samples based on DEseq normalized counts. Figure 8 shows the RPKM
relative abundance based on the union of the top 5 expressed genes in each sample. Figure 9 is a
heatmap showing gene expression patterns based on the hierarchical clustering of the top 5
percent of expressed genes across all samples. For analysis with equal or less than six samples,
scatter plots (Figure 10) is generated across samples based on log10(CPM).

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.pos = 'H')
library(rmarkdown)
library(knitr)
library(grid)
library(gridExtra)
library(RColorBrewer)
library(gplots)
library(limma)
library(ggplot2)
library(ComplexHeatmap)
library(reshape2)
library(circlize)
library(ggfortify)
library(edgeR)
library(ggpubr)
library(RColorBrewer)
library(rafalib)
library(genefilter)
library(gplots)
library(Biobase)
library(VennDiagram)
library(DESeq)
```

```{r definitions, echo=FALSE, warning=FALSE}
match_IDs<-function(from_counts, from_info){
  
  if (! all(colnames(from_counts) == from_info$SampleID)) {
  cat(file=stderr(),
      'Error: The IDs of the matrix (on the first line) and the metadata id do not match.\n'
  )
    return(FALSE)
} else {
  cat(file=stderr(),
      'QC Checkpoint Passed.\n'
  )
  return(TRUE)
}
}

```

```{r read, echo=FALSE, fig.width=10, fig.height=12, warning=FALSE, message=FALSE}
direc=unlist(params$pathd)
mapf<-unlist(params$mappingf)
setwd(direc)
GEPathD=paste0(direc,"/GE_Outputs/")
dir.create(file.path(direc, "/GE_Outputs/"), showWarnings = FALSE)
infoFile<-unlist(params$infof)
myinfo <- as.matrix(read.table(infoFile, check.names=FALSE, sep = "\t", as.is=TRUE))
infoF<-data.frame(read.table(infoFile,header=F,sep = "\t",as.is=TRUE, check.names = FALSE))
countsFile<-paste0(direc, "/all_counts.txt")
#non_norm_allcounts<-as.matrix(read.table(countsFile,header=TRUE,sep = "\t",as.is=TRUE, check.names = FALSE))
allcounts_htseq<-read.table(countsFile,header=TRUE,sep = "\t",as.is=TRUE, check.names = FALSE)
rownames(allcounts_htseq)<-allcounts_htseq$ID
allcounts_htseq$ID<-NULL
info_cond<-data.frame(infoF$V1, infoF$V2)
rownames(info_cond)<-infoF$V1
info_cond$infoF.V1<-NULL 

####Generating CPM files before normalization
####Dealing with 0s in counts file
y <- apply(as.matrix(allcounts_htseq), 2, as.numeric)
rownames(y)<-rownames(allcounts_htseq)
no0<-data.frame(y[rowSums(y)!=0, ], check.names = FALSE)
write.table(no0, file = paste0(GEPathD, "1_filtered_for_0_rowsum_counts.txt"), sep = "\t")
no1<-no0
no1[no1==0]<-1
write.table(no1, file = paste0(GEPathD,"2_Adjusted_No0_counts.txt"), sep = "\t")
cpmAllCounts<-cpm(no1)
write.table(cpmAllCounts, file = paste0(GEPathD,"3_CPM_counts_all_samples.txt"), sep = "\t")
logCPM<-log(cpmAllCounts)
write.table(logCPM, file = paste0(GEPathD,"4_logCPM_counts_all_samples.txt"), sep = "\t")

#Normalizing with deseq
condition <- factor(as.character(myinfo[,2]))
cds <- newCountDataSet(allcounts_htseq, condition)
cds <- estimateSizeFactors(cds)
###From v2b3 deseq.R
if (sum(ifelse((data.frame(table(as.character(myinfo[,2])))$Freq < 2), 1, 0)) > 0){
  cds <- estimateDispersions(cds, method="blind", sharingMode="fit-only", fitType="local")
} else {
  cds <- estimateDispersions(cds, method="pooled", sharingMode="fit-only", fitType="local")
}
out <- cbind(rownames(fData(cds)), fData(cds))
colnames(out) <- c("ID", colnames(fData(cds)))
write.table(out, file = paste0(GEPathD,"5_dispersion_counts.tsv"), na="NA", sep="\t", quote=F, row.names=F)
vsd <- varianceStabilizingTransformation(cds)
out_vsd <- cbind(rownames(exprs(vsd)), exprs(vsd))
colnames(out_vsd) <- c("ID", colnames(exprs(vsd)))
write.table(out_vsd, file = paste0(GEPathD,"6_all_counts_noZero_normalized.tsv"), na="NA", sep="\t", quote=F, row.names=F)

#allcounts<-counts(cds, normalized=TRUE)
allcounts <- data.frame(out_vsd, check.names = F)
allcounts_withID<-data.frame(out_vsd, check.names = F)
rownames(allcounts_withID)<-NULL

allcounts$ID <-NULL
Samplenames<-colnames(allcounts)
boxplot_df<-out_vsd
boxplot_df <- boxplot_df[,-1]
boxplot_df <- apply(boxplot_df,2, as.numeric)
rownames(boxplot_df)<-rownames(out_vsd)
mv<-melt(boxplot_df)

boxplot1<-ggplot(mv, aes(x = mv$Var2, y = mv$value, color=mv$Var2)) + geom_boxplot()+labs(x = "", y= "log Normalized Counts", fill=" ")+scale_fill_discrete(name = "Samples")+ theme(axis.text.x = element_text(angle = 90, hjust = 1))+ theme(legend.position="none")+coord_flip()

ggsave("Figure1.png", path = GEPathD, plot = boxplot1, height = 12, width = 10)


title_wrap<-strwrap("Figure 1. Boxplots of log Normalized Counts: This shows the expression profile of normalized read counts for each sample. The line dividing the box represents the median of the data and top and bottom of the box shows the upper and lower quartiles respectively. The whiskers show the highest and lowest values, excluding outliers, which are show as dots.", width = 150, simplify = F)

title_wrapped<-sapply(title_wrap, paste, collapse = "\n")
grid.arrange(boxplot1, top=textGrob(title_wrapped, gp=gpar(fontsize=11)))

```

```{r displayDensity, echo=FALSE, fig.height=8, fig.width=12, message=FALSE, warning=FALSE}
#\blandscape

dF.lCPM<- data.frame(boxplot_df, check.names = FALSE, stringsAsFactors = FALSE)
T.dF<-data.frame(t(dF.lCPM), keep.rownames=F, check.names = FALSE, stringsAsFactors = FALSE)
info.F<-data.frame(myinfo, check.names = FALSE, stringsAsFactors = FALSE)
rownames(info.F)<-info.F$V1
mergeGroups<- data.frame(merge(T.dF, info.F, by=0, all=TRUE), check.names = FALSE, stringsAsFactors = FALSE)
T.groups<-t(mergeGroups)
meltG<-melt(mergeGroups, id=c("Row.names", "keep.rownames", "V1", "V2", "V3"))
DensityG<-data.frame(meltG$Row.names, meltG$V2, meltG$variable, as.numeric(as.character(meltG$value)))
colnames(DensityG)<-c("SampleID","Group", "variable", "value")

title_wrap<-strwrap("Figure 2. Density of normalized log counts: This shows expression profile of normalized read counts for each sample, colored by group. The X-axis is the log-CPM (counts per million), and the Y-axis is the density  across the read counts for each sample. Density plots visualise the distribution of data over a continuous interval or time period", width = 150, simplify = F)

title_wrapped<-sapply(title_wrap, paste, collapse = "\n")
DensityG<-na.omit(DensityG)
density1<-ggplot(DensityG, aes(x=DensityG$value, group=DensityG$SampleID, color=Group)) + geom_density()+labs(x="logCPM", y="Density",fill="")+geom_hline(yintercept = 0)
grid.arrange(density1, top=textGrob(title_wrapped, gp=gpar(fontsize=11)))
ggsave("Figure2.png", path = GEPathD, plot = density1, height = 8, width = 12)

#\elandscape
```

```{r heatmapE, echo=FALSE, fig.height=12, fig.width=10, warning=FALSE}
myinfo <- as.matrix(read.table(infoFile, check.names=FALSE, sep = "\t", as.is=TRUE))
scaled<-(scale(boxplot_df))
scaled<-scaled[,order(colnames(scaled))]
tbox<-data.frame(myinfo[,1], myinfo[,2])
colnames(tbox)<-c("SampleID", "Group")
map.all=tbox[order(tbox$SampleID),]
ha_type<-data.frame(map.all$Group)

#Check if names match in counts and info file
qc_passed<-match_IDs(scaled, map.all) 
if (qc_passed == T) {
EucDist<-as.matrix(dist((t(scaled)), method="euclidean"))
ha_type<-data.frame(map.all$Group)
colnames(ha_type)<-"Group"
ttbox<-melt(tbox, id=c("SampleID", "Group"))
#Attempt to color correctly
no_groups<-unlist(unique(ha_type))
myColors<-c("blue", 
                  "deeppink3", 
                  "magenta",
                  "chartreuse4",
                  "darkblue",
                  "darkorange",
                  "darkorchid1",
                  "hotpink4",
                  "cyan",
                  "goldenrod4",
                  "orangered",
                  "tan3",
                  "steelblue4",
                  "dodgerblue1",
                  "darkslategray",
                  "lightslateblue",
                  "lightcoral",
                  "purple4",
                  "darkseagreen",
                  "aquamarine4")
#pie(rep(1, length(myColors)), col =  myColors, main="")
str_col=""
for(grp in 1:length(no_groups)){
  str_col= paste0(str_col, no_groups[grp],"='",myColors[grp],"'")
  if(grp != length(no_groups)){
    str_col= paste0(str_col, ",")
  }
}
ha_dynamic_str<-paste0('HeatmapAnnotation(df = data.frame(ha_type = ha_type), annotation_legend_param = list(title="Condition", 
                   title_gp = gpar(fontsize = 10, fontface=2, fontfamily="Helvetica")), col = list(Group =c(', str_col, ')))')
ha_types<-eval(parse(text=ha_dynamic_str))

title_wrap<-strwrap("Figure 3. Sample clustering by Euclidean distance: This heatmap was computed by Euclidean distance of expression, based on normalized data (CPM). Color coding is by Euclidean distance and by group/condition. This figure can indicate the relationship between the samples and groups.", width = 150, simplify = F)

title_wrapped<-sapply(title_wrap, paste, collapse = "\n")

hold_heatmap_1<-Heatmap(EucDist,name="Euc dist", column_title = gpar(title_wrapped), column_title_gp = gpar(fontsize=9), column_title_side = "top", top_annotation = ha_types, heatmap_legend_param = list(labels_gp = gpar(fontsize = 5, fontfamily="Helvetica")),column_names_gp = gpar(fontsize = 6), show_row_names = FALSE)

draw(hold_heatmap_1)
}
```

```{r heatmapESave, echo=FALSE, fig.height=12, fig.width=10, warning=FALSE}
#Save Heatmap as png
heatmap_out_name = paste0(GEPathD, "/Figure_3_DE_Euc_Heamap.png")
png(heatmap_out_name, res=100, width = 10, height =8, units = "in")
draw(hold_heatmap_1)
invisible(dev.off())
```

```{r heatmapP, echo=FALSE, warning=FALSE, fig.width=10, fig.height=12}
qc_passed<-match_IDs(scaled, map.all) 
if (qc_passed == T) {
pcor<-cor(scaled, use="complete.obs", method = "pearson")
title_wrap<-strwrap("Figure 4. Sample clustering by Pearson co-efficient: This heatmap was computed by Pearson co-efficient of expression, based on normalized data (CPM). Color coding is by Pearson co-efficient and by group/condition. This figure can indicate the relationship between the samples and groups.", width = 150, simplify = F)

title_wrapped<-sapply(title_wrap, paste, collapse = "\n")

hold_heatmap2<-Heatmap(pcor,  name="Pearson", column_title = gpar(title_wrapped), column_title_gp = gpar(fontsize=9), column_title_side = "top", top_annotation = ha_types, heatmap_legend_param = list(labels_gp = gpar(fontsize = 5, fontfamily="Helvetica")), row_names_gp = gpar(fontsize = 6), column_names_gp = gpar(fontsize = 6), show_row_names = FALSE)
draw(hold_heatmap2)
}
```

```{r heatmapPSave, echo=FALSE, fig.height=12, fig.width=10, warning=FALSE}
#Save Heatmap as png
heatmap_out_name = paste0(GEPathD, "/Figure_4_DE_pearson_corr_Heamap.png")
png(heatmap_out_name, res=100, width = 10, height =8, units = "in")
draw(hold_heatmap2)
invisible(dev.off())
```
\newpage
```{r dend, echo=FALSE, fig.height=12, fig.width=20, warning=FALSE}
#
###colorless dendrogram if IDs dont match
EDden<-hclust(dist(t(scaled), method = "euclidean"))
Pcorden<-cor(scaled, use="complete.obs", method = "pearson")
pClust<-hclust(dist(Pcorden))
if (! all(colnames(scaled) == map.all$SampleID)) {
  cat(file=stderr(),
      'Error: The IDs of the matrix (on the first line) and the metadata id do not match.\n'
  )
  plot(EDden, cex=1.5, cex.main=1.5, xlab="", main="Figure 5. Sample clustering illustrated by a dendogram using Euclidean distance computed from gene expression across samples.")
  
  plot(pClust, cex=1.5, cex.main=1.5, xlab="", main="Figure 6. Sample clustering illustrated by a dendogram using pairwise correlation computed from gene expression across samples.")
  
} else {
EDden<-hclust(dist(t(scaled), method = "euclidean"))
samplecols<-data.frame()
colormap<-list()
######Arranging sample ids and assigning color
for(i in 1:length(unique(map.all$Group)))
{
  tempSample<-data.frame(map.all[which(map.all$Group==unique(map.all$Group)[i]),])
  temp_col<-myColors[i]
  for(j in 1: nrow(tempSample))
  {
    tempSample$color[j]<-temp_col
  }
  Samtemp<-list(tempSample$SampleID)
  samplecols<-rbind(samplecols, tempSample)
}
#Samexpr<-samplecols$SampleID
edclust_dend<-myplclust(EDden, labels=samplecols$SampleID, lab.col=samplecols$color, hang = 0.01, cex=1,cex.main=1, cex.sub=1, main = "Figure 5. Sample clustering illustrated by a dendogram using euclidean distance computed from gene expression across samples.") 
Pcorden<-cor(scaled, use="complete.obs", method = "pearson")
pClust<-hclust(dist(Pcorden))

pclust_dend<-myplclust(pClust, labels=samplecols$SampleID, lab.col=samplecols$color, hang = 0.01, cex=1,cex.main=1, cex.sub=1, main = "Figure 6. Sample clustering illustrated by a dendogram using pairwise correlation computed from gene expression across samples.")

#plot(EDden, font.main = 1, xlab="",sub="", main="Figure 5. Euclidean distance Dendrogram: The dendrogram was computed by Euclidean distance of expression, based on normalized data (CPM).")
#plot(pClust, font.main = 1, xlab="",sub="", main="Figure 6. Pearson co-efficient Dendrogram: The dendrogram was computed by Pearson co-efficient of expression, based on normalized data (CPM).")
}
#
```

```{r DendSave, echo=FALSE, warning=FALSE, fig.show=F}
#Save Heatmap as png
eden_out_name = paste0(GEPathD, "/Figure_5_DE_Euc_dendrogram.png")
png(eden_out_name, res=100, width = 14, height =8, units = "in")
edclust_dend<-myplclust(EDden, labels=samplecols$SampleID, lab.col=samplecols$color, hang = 0.01, cex=1,cex.main=1, cex.sub=1, main = "Figure 5. Sample clustering illustrated by a dendogram using euclidean distance computed from gene expression across samples.") 
invisible(dev.off())

pden_out_name = paste0(GEPathD, "/Figure_6_DE_PC_dendrogram.png")
png(pden_out_name, res=100, width = 14, height =8, units = "in")
pclust_dend<-myplclust(pClust, labels=samplecols$SampleID, lab.col=samplecols$color, hang = 0.01, cex=1,cex.main=1, cex.sub=1, main = "Figure 6. Sample clustering illustrated by a dendogram using pairwise correlation computed from gene expression across samples.")
invisible(dev.off())
```
\newpage
```{r PCA, echo=FALSE, fig.width=10, fig.height=10, warning=FALSE}
if (qc_passed == T) {
tv_test<-t(boxplot_df)
PC<-prcomp(tv_test)
PC.df<-data.frame(PC$x)
Group.pc<-data.frame(merge(PC.df, info_cond, by=0, all=TRUE))
drops <- c("V1","V3", "V4")
filtered.G<-Group.pc[ , !(names(Group.pc) %in% drops)]
PCA1<-ggplot(filtered.G,aes(x=PC1,y=PC2,col=filtered.G$infoF.V2))+geom_point(size=3)+theme_classic()+theme(text = element_text(size=12), legend.position="top")+labs(colour="Groups")

title_wrap<-strwrap("Figure 7. Correlation between samples: This PCA (Principal Component Analysis) plot indicates the relationships between all samples (position) from each group and between groups (color). The analysis was performed on normalized counts using the singular value decomposition method.", width = 120, simplify = F)

title_wrapped<-sapply(title_wrap, paste, collapse = "\n")

hold_pca<-grid.arrange(PCA1, top=textGrob(title_wrapped, gp=gpar(fontsize=10)))
ggsave("Figure7.png", path = GEPathD, plot = hold_pca, height = 10, width = 10)
}
```

\newpage

```{r topgenes, echo=FALSE, warning=FALSE, fig.width=15, fig.height=10}
#\blandscape
RPKMfile<-paste0(direc,"/RPKM/")
if(dir.exists(RPKMfile) && length(list.files(RPKMfile))>=1)
{
rpkmfiles<-list.files(RPKMfile, full.names = TRUE)
dataset<-do.call(cbind,lapply(rpkmfiles, read.table))
sample.no<-ncol(dataset)/11
count4=4
count11=11
colid<-vector()
gene_names<-data.frame()
geneV<-vector()
##collect all RPKMcolums in colid and genecolumns in GeneV
for(i in 1:sample.no)
{
  colid<-c(colid, count11)
  geneV<-c(geneV, count4)
  count4=count4+11
  count11=count11+11
  
}


filteredGene<- dataset[, geneV]
filteredRPKM<- dataset[, colid]
finalDS<-data.frame()
if(length(unique(as.list(filteredGene))) == 1)
{
  finalDS<-cbind(filteredGene$V4, filteredRPKM)
}
top=list()
topGene<-data.frame()
###getting top 5 for each sample
for (s in (2:ncol(finalDS))) {
  t1<-finalDS[with(finalDS, order(-finalDS[s] )), ]
  t2<-list(head(t1$`filteredGene$V4`, 5))
  top<-append(top, t2)
}
topUnlist<-unlist(top)
TopUnique<-unique(topUnlist)

####get the lines for the unique top genes from finalDS
geneRpkm<-finalDS[finalDS$`filteredGene$V4` %in% TopUnique,]
rpkm.mat<-as.matrix(sapply(geneRpkm, as.numeric))
rpkm.num<-rpkm.mat[,-1]
relAb<-rpkm.num/rowSums(rpkm.num)
relAb<-data.frame(relAb)
relAb<-cbind(geneRpkm$`filteredGene$V4`, relAb)
meltGene<-melt(relAb, id="geneRpkm$`filteredGene$V4`")
colnames(meltGene)[1]<-"Gene"
meltGene<-meltGene[order(meltGene$value),]
if(mapf=="none")
{
  #meltGene$Gene<-factor(meltGene$Gene, levels=unique(meltGene$Gene))
    RelRPKM1<-ggplot(meltGene, aes(x = meltGene$Gene, y = value, fill=meltGene$Gene)) +geom_boxplot()+labs(x = "", y= "RPKM Relative Abundance")+
    geom_dotplot(binaxis='y', stackdir='center', dotsize = 0.01, binwidth=0.01)+ scale_fill_discrete(name = "")+ theme(text = element_text(size=10), axis.text.x = element_text(angle=90, hjust=1), legend.position="top") + guides(fill=FALSE)
}
else
{
    Mapping<-read.table(mapf, check.names=FALSE, header = TRUE, fill = TRUE)
    newdf_map<-merge(meltGene, Mapping, by='Gene', all.x=TRUE)
    for(i in 1:length(newdf_map$Genename))
    {
      if(is.na(newdf_map$Genename[i])==TRUE)
      {
        hold1<-toString((newdf_map$Gene[i]))
        newdf_map$Genename2[i]=hold1
        #print(newdf_map$Genename[i])
        #print(newdf_map$Gene[i])
      }
      else{
        hold1<-toString((newdf_map$Genename[i]))
        newdf_map$Genename2[i]=hold1
      }
    }

    Finalmap<-data.frame(newdf_map$Genename2, newdf_map$variable, newdf_map$value)
    colnames(Finalmap)<-c("GeneName", "variable", "value")

    RelRPKM1<-ggplot(Finalmap, aes(x = Finalmap$GeneName, y = value, fill=Finalmap$GeneName)) +geom_boxplot()+labs(x = "", y= "RPKM Relative Abundance")+
  geom_dotplot(binaxis='y', stackdir='center', dotsize = 0.01, binwidth=0.01)+ scale_fill_discrete(name = "")+
  theme(text = element_text(size=10), axis.text.x = element_text(angle=90, hjust=1), legend.position="top")+
  guides(fill=FALSE)
}

title_wrap<-strwrap("Figure 8. RPKM Relative Abundance: This figure visualizes the union of top 5 most abundant genes for each sample. The median line and the range of each box indicates the expression levels for each gene in all samples. The whiskers show the highest and lowest values, excluding outliers, which are show as dots.", width = 200, simplify = F)

title_wrapped<-sapply(title_wrap, paste, collapse = "\n")

hold_rel_rpkm<-grid.arrange(RelRPKM1, top=textGrob(title_wrapped, gp=gpar(fontsize=12)))
ggsave("Figure8.png", path = GEPathD, plot = hold_rel_rpkm, height = 8, width = 18)
}
#\elandscape
```

```{r geneHeatmap, echo=FALSE, warning=FALSE, fig.width=10, fig.height=12}
dfCPM<-data.frame(t(scaled), check.names = FALSE)
sdCPM<-sapply(dfCPM, sd, na.rm = FALSE)
df.sd<-data.frame(sdCPM)
df.SD<-data.frame(rownames(df.sd), df.sd$sdCPM)
colnames(df.SD)<-c("Gene", "SD")
sortedSD<-df.SD[order(-df.SD$SD), ]
topPercent<-round((nrow(sortedSD)*5)/100)
top299<-sortedSD[1:topPercent, ]
top299Gene<-unlist(top299$Gene)
#DF.logCPM<-data.frame(logCPM)
DF.logCPM<-data.frame(scaled)
#topGenes<-logCPM[rownames(DF.logCPM) %in% top299Gene, ]
topGenes<-scaled[rownames(DF.logCPM) %in% top299Gene, ]
write.table(topGenes, file = paste0(GEPathD, "CPM_Top5percent.txt"), sep = "\t")
scaled299<-scale(topGenes)
EucDist299<-dist((t(scaled299)), method="euclidean")

title_wrap<-strwrap("Figure 9. Sample clustering based on CPM: The heatmap illustrates the sample correlation computed from gene expression count values. It shows how well the samples from each group cluster based on gene expression counts.", width = 120, simplify = F)

title_wrapped<-sapply(title_wrap, paste, collapse = "\n")

if (qc_passed == T) {
  sorted_top<-scaled299[order(rowMeans(scaled299), decreasing = TRUE), ]
  if(mapf=="none")
  {
    ha.melt<-data.frame(rowMeans(sorted_top))
    ht1<- Heatmap(sorted_top, show_row_names = FALSE, name="scaledCPM", column_title = gpar(title_wrapped), column_title_gp = gpar(fontsize=10), column_title_side = "top", top_annotation = ha_types, cluster_rows = FALSE, column_names_gp=gpar(fontsize=6))
  }
  
####Adding gene names
  
  else
  {
    if(nrow(sorted_top)<60)
    {
      mergedf<-merge(sorted_top, Mapping, by.x=0, by.y="Gene", all.x=TRUE)
      for(i in 1:length(mergedf$Row.names))
      {
        if(is.na(mergedf$Genename[i])==TRUE)
        {
          hold1<-toString((mergedf$Row.names[i]))
          mergedf$Genename2[i]=hold1
        }
        else{
          hold1<-toString((mergedf$Genename[i]))
          mergedf$Genename2[i]=hold1
        }
        mergedf$isUnique<-isUnique(mergedf$Genename2)
        if(mergedf$isUnique[i]=="FALSE")
          {
            hold1<-paste0(toString((mergedf$Genename2[i])), "-", toString(mergedf$Row.names[i]))
            mergedf$Genename2[i]=hold1
          }
      }
      rownames(mergedf)<-master_df$Genename2
      mergedf$Genename<-NULL
      mergedf$Row.names<-NULL
      mergedf$Genename2<-NULL
      mergedf$isUnique<-NULL
      merged_df_sorted<-mergedf[order(rowMeans(mergedf), decreasing = TRUE), ]
      ha.melt<-data.frame(rowMeans(merged_df_sorted))
      ht1<- Heatmap(merged_df_sorted, show_row_names = TRUE, name="scaledCPM", column_title = gpar(title_wrapped),
                column_title_gp = gpar(fontsize=10), column_title_side = "top", 
                top_annotation = ha_types, cluster_rows = FALSE, column_names_gp=gpar(fontsize=4), 
                row_names_gp=gpar(fontsize=6), row_names_side = "left")
      
    }
    else
    {
      ha.melt<-data.frame(rowMeans(sorted_top))
      ht1<- Heatmap(sorted_top, show_row_names = FALSE, name="scaledCPM", column_title = gpar(title_wrapped), column_title_gp = gpar(fontsize=10), column_title_side = "top", top_annotation = ha_types, cluster_rows = FALSE, column_names_gp=gpar(fontsize=6))
    }
  }
  
  colnames(ha.melt)[1]<-"Mean"
  maxR<- max(ha.melt$Mean)
  minR<-min(ha.melt$Mean)
  ha.h<-rowAnnotation(df=data.frame(ha.melt$Mean),show_legend = FALSE, col=list(Mean=colorRamp2(c(minR,maxR), c("red", "blue"))))

ht2<-Heatmap(data.frame(ha.melt$Mean), cluster_rows = FALSE, width = 0.25, show_heatmap_legend = FALSE, 
             show_row_names = FALSE, show_column_names = FALSE, col = colorRamp2(c(minR, maxR), c("gray", "pink")))
htlist=ht1 +  ht2
draw(htlist)
}
```

```{r pair, echo=FALSE, warning=FALSE, fig.width=10, fig.height=12}
if(nrow(t(cpmAllCounts))<=6)
{
  pairs(scaled,pch=20, cex.main=0.75,main="Figure 10. Scatterplots: Matrix of scatterplots comparing all samples")
}
```
